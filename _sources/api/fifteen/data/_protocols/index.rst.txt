:orphan:

:mod:`fifteen.data._protocols`
==============================

.. py:module:: fifteen.data._protocols

.. autoapi-nested-parse::

   Structural supertypes for working with datasets and dataloaders.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   fifteen.data._protocols.SizedIterable
   fifteen.data._protocols.MapDatasetProtocol
   fifteen.data._protocols.DataLoaderProtocol




Attributes
~~~~~~~~~~

.. autoapisummary::

   fifteen.data._protocols.ContainedType


.. data:: ContainedType
   

   

.. class:: SizedIterable

   Bases: :py:obj:`Iterable`\ [\ :py:obj:`ContainedType`\ ], :py:obj:`Sized`, :py:obj:`Protocol`\ [\ :py:obj:`ContainedType`\ ]

   .. autoapi-inheritance-diagram:: fifteen.data._protocols.SizedIterable
      :parts: 1

   Protocol for objects that define both ``__iter__()`` and ``__len__()`` methods.

   This is particularly useful for managing minibatches, which can be iterated over but
   only in order due to multiprocessing/prefetching optimizations, and for which length
   evaluation is useful for tools like ``tqdm``.


.. class:: MapDatasetProtocol

   Bases: :py:obj:`Protocol`\ [\ :py:obj:`ContainedType`\ ]

   .. autoapi-inheritance-diagram:: fifteen.data._protocols.MapDatasetProtocol
      :parts: 1

   Protocol for defining PyTorch-style "map" datasets, which implement two methods:
   ``__getitem__()`` for loading single samples and ``__len__()`` for counting the total
   number of samples.

   This is similar to collections.abc.Mapping, but does not require implementations of
   ``__contains__()``.

   .. method:: __getitem__(self, index: int, /) -> ContainedType


   .. method:: __len__(self) -> int



.. class:: DataLoaderProtocol

   Bases: :py:obj:`Protocol`\ [\ :py:obj:`ContainedType`\ ]

   .. autoapi-inheritance-diagram:: fifteen.data._protocols.DataLoaderProtocol
      :parts: 1

   Protocol for dataloaders, which are used to generate minibatches that can be
   iterated over.

   .. attribute:: minibatch_size
      :annotation: :int

      

   .. method:: minibatch_count(self) -> int


   .. method:: minibatches(self, shuffle_seed: Optional[int]) -> SizedIterable[ContainedType]



